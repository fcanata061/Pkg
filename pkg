#!/bin/bash
# ================================================
# pkg - Interface de alto nível do gerenciador
# ================================================

set -euo pipefail

. ./pkg.conf
. "$SCRIPT1"
. "$SCRIPT2"

# Mensagens coloridas
msg()     { echo -e "${CYAN}==>${RESET} $*"; }
success() { echo -e "${GREEN}✔${RESET} $*"; }
warn()    { echo -e "${YELLOW}⚠${RESET} $*"; }
error()   { echo -e "${RED}✘${RESET} $*"; }

# ------------------------------------------------
# Sync do repositório (git pull/clone)
# ------------------------------------------------
pkg_sync() {
    if [ -d "$REPO_DIR/.git" ]; then
        msg "Sincronizando repositório em $REPO_DIR (git pull)"
        git -C "$REPO_DIR" pull || { error "git pull falhou"; exit 1; }
    else
        if [ -n "${REPO_GIT_URL:-}" ]; then
            msg "Clonando repositório $REPO_GIT_URL em $REPO_DIR"
            git clone "$REPO_GIT_URL" "$REPO_DIR" || { error "git clone falhou"; exit 1; }
        else
            error "Repositório não é um clone git e REPO_GIT_URL não foi definido"
            exit 1
        fi
    fi
    success "Repositório sincronizado"
}

# ------------------------------------------------
# Comparar versões usando sort -V
# retorna 0 se new > cur (upgrade necessário)
# ------------------------------------------------
needs_upgrade() {
    local cur="$1"
    local new="$2"
    [ "$(printf '%s\n%s\n' "$cur" "$new" | sort -V | tail -n1)" != "$cur" ]
}

# ------------------------------------------------
# Upgrade: recompila apenas pacotes instalados com versão maior
# ------------------------------------------------
pkg_upgrade() {
    msg "Verificando upgrades disponíveis para pacotes instalados..."
    local upgraded_any=0
    for pkgdb in "$DB_DIR"/*; do
        [ -d "$pkgdb" ] || continue
        local pkg="$(basename "$pkgdb")"
        local curfile="$pkgdb/installed"
        [ -f "$curfile" ] || continue
        local curver
        curver="$(cat "$curfile")"

        if find_pkg "$pkg" >/dev/null 2>&1; then
            local dir
            dir="$(find_pkg "$pkg")"
            # shellcheck disable=SC1090
            source "$dir/build.txt"
            if needs_upgrade "$curver" "$version"; then
                warn "Upgrade: $pkg ($curver → $version)"
                pkg_depsolve "$pkg"
                pkg_fetch "$pkg"
                pkg_prepare "$pkg"
                pkg_build "$pkg"
                pkg_install "$pkg" 1
                upgraded_any=1
            fi
        fi
    done
    if [ "$upgraded_any" -eq 0 ]; then
        success "Nenhum upgrade necessário"
    else
        success "Upgrades concluídos"
    fi
}

# ------------------------------------------------
# Ordenação por dependências (toposort simples)
# gera ordem de build para uma lista de pacotes
# ------------------------------------------------
_topo_visit() {
    local pkg="$1"
    local -n mark_ref="$2"   # associative array: mark
    local -n order_ref="$3"  # array: order

    # 0=unmarked, 1=temp, 2=perm
    local state="${mark_ref[$pkg]:-0}"
    if [ "$state" -eq 1 ]; then
        error "Ciclo de dependências detectado envolvendo $pkg"
        exit 1
    elif [ "$state" -eq 2 ]; then
        return 0
    fi

    mark_ref["$pkg"]=1

    if find_pkg "$pkg" >/dev/null 2>&1; then
        local dir
        dir="$(find_pkg "$pkg")"
        # shellcheck disable=SC1090
        source "$dir/build.txt"
        if declare -p depends >/dev/null 2>&1; then
            local d
            for d in "${depends[@]}"; do
                _topo_visit "$d" mark_ref order_ref
            done
        fi
    fi

    mark_ref["$pkg"]=2
    order_ref+=("$pkg")
}

resolve_build_order() {
    # entrada: lista de pacotes (alvo)
    declare -A mark=()
    local order=()
    local p
    for p in "$@"; do
        _topo_visit "$p" mark order
    done
    printf '%s\n' "${order[@]}"
}

# ------------------------------------------------
# World: recompilar TODO o sistema instalado, respeitando dependências
# ------------------------------------------------
pkg_world() {
    msg "Recompilando todo o sistema (world) com ordenação de dependências..."

    # pega todos os pacotes instalados
    local installed=()
    local pkgdb
    for pkgdb in "$DB_DIR"/*; do
        [ -d "$pkgdb" ] || continue
        installed+=("$(basename "$pkgdb")")
    done

    if [ "${#installed[@]}" -eq 0 ]; then
        warn "Nenhum pacote instalado no DB para world"
        return 0
    fi

    # resolve ordem
    mapfile -t order < <(resolve_build_order "${installed[@]}")

    # remove duplicatas preservando ordem
    awk '!seen[$0]++' <<< "$(printf '%s\n' "${order[@]}")" | while read -r pkg; do
        [ -z "$pkg" ] && continue
        msg "WORLD → recompilando $pkg"
        pkg_depsolve "$pkg"
        pkg_fetch "$pkg"
        pkg_prepare "$pkg"
        pkg_build "$pkg"
        pkg_install "$pkg" 1
    done

    success "World concluído"
}

# ------------------------------------------------
# Ajuda
# ------------------------------------------------
usage() {
    cat <<EOF
Uso: pkg <comando> [opções] [pacotes]

Comandos:
  install [--force] <pkg>...   Resolver deps, compilar em fakeroot e instalar no /
  build <pkg>...               Apenas compila (sem instalar)
  remove <pkg>...              Remove pacote instalado usando manifesto
  revdep                       Corrige dependências quebradas e remove órfãos
  depsolve <pkg>               Resolve e instala dependências de um pacote
  sync                         Sincroniza o repositório Git (git pull/clone)
  upgrade                      Recompila/reinstala apenas pacotes com versão maior
  world                        Recompila todo o sistema instalado (ordem por deps)

Exemplos:
  pkg sync
  pkg install zlib
  pkg install --force autoconf
  pkg build bash
  pkg remove htop
  pkg upgrade
  pkg world
EOF
}

# ------------------------------------------------
# Dispatcher
# ------------------------------------------------
cmd="${1:-}"
shift || true

case "$cmd" in
    install)
        FORCE=0
        if [ "${1:-}" = "--force" ]; then
            FORCE=1; shift
        fi
        if [ "$#" -lt 1 ]; then usage; exit 1; fi
        for p in "$@"; do
            msg "Instalando $p (force=$FORCE)"
            pkg_depsolve "$p"
            pkg_fetch "$p"
            pkg_prepare "$p"
            pkg_build "$p"
            pkg_install "$p" "$FORCE"
        done
        ;;
    build)
        if [ "$#" -lt 1 ]; then usage; exit 1; fi
        for p in "$@"; do
            msg "Build de $p"
            pkg_fetch "$p"
            pkg_prepare "$p"
            pkg_build "$p"
        done
        ;;
    remove)
        if [ "$#" -lt 1 ]; then usage; exit 1; fi
        for p in "$@"; do
            msg "Removendo $p"
            pkg_remove "$p"
        done
        ;;
    revdep)
        pkg_revdep
        ;;
    depsolve)
        if [ "$#" -ne 1 ]; then usage; exit 1; fi
        pkg_depsolve "$1"
        ;;
    sync)
        pkg_sync
        ;;
    upgrade)
        pkg_upgrade
        ;;
    world)
        pkg_world
        ;;
    ""|-h|--help|help)
        usage
        ;;
    *)
        error "Comando desconhecido: $cmd"
        usage
        exit 1
        ;;
esac
