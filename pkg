#!/bin/bash
# ================================================
# pkg - Interface do gerenciador (CLI)
# ================================================

set -euo pipefail

. ./pkg.conf
. "$SCRIPT1"
. "$SCRIPT2"

# -------- util --------
msg()     { echo -e "${CYAN}${ICON_INFO}${RESET} $*"; }
success() { echo -e "${GREEN}${ICON_OK}${RESET} $*"; }
warn()    { echo -e "${YELLOW}${ICON_WARN}${RESET} $*"; }
error()   { echo -e "${RED}${ICON_FAIL}${RESET} $*"; }

needs_upgrade() {
    local cur="$1"; local new="$2"
    [ "$(printf '%s\n%s\n' "$cur" "$new" | sort -V | tail -n1)" != "$cur" ]
}

# -------- sync (git) --------
pkg_sync() {
    if [ -d "$REPO_DIR/.git" ]; then
        msg "Sincronizando repositório: git pull"
        git -C "$REPO_DIR" pull
    else
        if [ -n "${REPO_GIT_URL:-}" ]; then
            msg "Clonando repositório: $REPO_GIT_URL"
            git clone "$REPO_GIT_URL" "$REPO_DIR"
        else
            error "REPO_GIT_URL não definido e $REPO_DIR não é um clone git"
            exit 1
        fi
    fi
    success "Sync OK"
}

# -------- search --------
pkg_search() {
    local term="${1:-}"
    [ -z "$term" ] && { echo "uso: pkg search <termo>"; exit 1; }
    local r p
    for r in "${REPOS[@]}"; do
        [ -d "$REPO_DIR/$r" ] || continue
        for p in "$REPO_DIR/$r"/*; do
            [ -d "$p" ] || continue
            local name="$(basename "$p")"
            if echo "$name" | grep -qi "$term"; then
                echo -e "${GREEN}$name${RESET}  (${DIM}$r${RESET})"
                continue
            fi
            # procurar descrição no build.txt (desc="...")
            if grep -qiE '^desc=|^description=' "$p/build.txt" 2>/dev/null; then
                if grep -qi "$term" "$p/build.txt"; then
                    echo -e "${GREEN}$name${RESET}  (${DIM}$r${RESET})"
                fi
            fi
        done
    done
}

# -------- info --------
pkg_info() {
    local pkg="$1"
    [ -z "$pkg" ] && { echo "uso: pkg info <pacote>"; exit 1; }
    local dir; dir="$(find_pkg "$pkg")" || { error "Pacote $pkg não encontrado no repo"; exit 1; }
    # shellcheck disable=SC1090
    source "$dir/build.txt"
    echo -e "${BOLD}$name $version${RESET}"
    [ -n "${release:-}" ] && echo "release: ${release}"
    [ -n "${desc:-}" ] && echo "desc   : ${desc}"
    echo "repo   : $(basename "$(dirname "$dir")")"
    if declare -p depends >/dev/null 2>&1; then
        echo "depends: ${depends[*]}"
    else
        echo "depends: (none)"
    fi
    if [ -f "$SQLITE_DB" ]; then
        local inst="$(sqlite3 "$SQLITE_DB" "SELECT version FROM packages WHERE name='$name';")"
        [ -n "$inst" ] && echo -e "instalado: ${GREEN}$inst${RESET}"
    elif [ -d "$DB_DIR/$name" ]; then
        echo -e "instalado: ${GREEN}$(cat "$DB_DIR/$name/installed")${RESET}"
    fi
}

# -------- upgrade --------
pkg_upgrade() {
    msg "Procurando upgrades…"
    local upgraded_any=0
    for pkgdb in "$DB_DIR"/*; do
        [ -d "$pkgdb" ] || continue
        local pkg="$(basename "$pkgdb")"
        local cur
        if [ -f "$SQLITE_DB" ]; then
            cur="$(sqlite3 "$SQLITE_DB" "SELECT version FROM packages WHERE name='$pkg';")"
        else
            cur="$(cat "$pkgdb/installed" 2>/dev/null || true)"
        fi
        [ -z "$cur" ] && continue
        if find_pkg "$pkg" >/dev/null 2>&1; then
            local dir; dir="$(find_pkg "$pkg")"
            # shellcheck disable=SC1090
            source "$dir/build.txt"
            if needs_upgrade "$cur" "$version"; then
                warn "Upgrade: $pkg ($cur → $version)"
                pkg_depsolve "$pkg"
                pkg_fetch "$pkg"
                pkg_prepare "$pkg"
                pkg_build "$pkg"
                pkg_install "$pkg" 1
                upgraded_any=1
            fi
        fi
    done
    [ "$upgraded_any" -eq 0 ] && success "Nenhum upgrade disponível" || success "Upgrades concluídos"
}

# -------- world (ordenação por deps) --------
_topo_visit() {
    local pkg="$1"; local -n mark="$2"; local -n order="$3"
    local st="${mark[$pkg]:-0}"
    [ "$st" -eq 1 ] && { error "Ciclo de dependências envolvendo $pkg"; exit 1; }
    [ "$st" -eq 2 ] && return 0
    mark["$pkg"]=1
    if find_pkg "$pkg" >/dev/null 2>&1; then
        local dir; dir="$(find_pkg "$pkg")"
        # shellcheck disable=SC1090
        source "$dir/build.txt"
        if declare -p depends >/dev/null 2>&1; then
            local d; for d in "${depends[@]}"; do _topo_visit "$d" mark order; done
        fi
    fi
    mark["$pkg"]=2
    order+=("$pkg")
}

resolve_build_order() {
    local -a targets=("$@"); declare -A mark=(); local -a order=()
    local p; for p in "${targets[@]}"; do _topo_visit "$p" mark order; done
    printf '%s\n' "${order[@]}"
}

pkg_world() {
    msg "Recompilando world (ordenado por dependências)…"
    local installed=()
    for d in "$DB_DIR"/*; do [ -d "$d" ] && installed+=("$(basename "$d")"); done
    [ "${#installed[@]}" -eq 0 ] && { warn "Sem pacotes instalados"; return 0; }
    mapfile -t order < <(resolve_build_order "${installed[@]}")
    # remove duplicatas preservando a ordem
    local uniq; uniq="$(printf '%s\n' "${order[@]}" | awk '!seen[$0]++')"
    while IFS= read -r p; do
        [ -z "$p" ] && continue
        msg "WORLD → $p"
        pkg_depsolve "$p"
        pkg_fetch "$p"
        pkg_prepare "$p"
        pkg_build "$p"
        pkg_install "$p" 1
    done <<< "$uniq"
    success "World concluído"
}

# -------- clean --------
pkg_clean() {
    local what="${1:-all}"
    case "$what" in
        sources)  msg "Limpando sources em $SRC_DIR";  rm -rf "$SRC_DIR"/* ;;
        build)    msg "Limpando builds em $BUILD_DIR"; rm -rf "$BUILD_DIR"/* ;;
        fakeroot) msg "Limpando fakeroot em $PKG_DIR"; rm -rf "$PKG_DIR"/* ;;
        logs)     msg "Limpando logs em $LOG_DIR";     rm -rf "$LOG_DIR"/* ;;
        all)      msg "Limpando tudo (sources/build/fakeroot/logs)"; rm -rf "$SRC_DIR"/* "$BUILD_DIR"/* "$PKG_DIR"/* "$LOG_DIR"/* ;;
        *) echo "uso: pkg clean [sources|build|fakeroot|logs|all]"; exit 1 ;;
    esac
    success "Clean OK"
}

# -------- check --------
pkg_check() {
    msg "Verificando consistência de instalação…"
    local issues=0
    for pkgdb in "$DB_DIR"/*; do
        [ -d "$pkgdb" ] || continue
        local pkg="$(basename "$pkgdb")"
        local manifest="$pkgdb/files.lst"
        [ -f "$manifest" ] || continue
        while IFS= read -r rel; do
            [ -z "$rel" ] && continue
            local abs="$ROOT_DIR/$rel"
            if [ ! -e "$abs" ]; then
                warn "[missing] $pkg: /$rel"
                issues=1
            fi
        done < "$manifest"
    done
    [ "$issues" -eq 0 ] && success "Check OK" || warn "Check encontrou problemas (veja mensagens acima)"
}

# -------- chroot --------
pkg_chroot() {
    local dir="$1"
    [ -z "$dir" ] && { echo "uso: pkg chroot <dir>"; exit 1; }
    mkdir -p "$dir"/{proc,sys,dev,run,tmp}
    mountpoint -q "$dir/proc" || mount -t proc proc "$dir/proc"
    mountpoint -q "$dir/sys"  || mount --rbind /sys "$dir/sys"
    mountpoint -q "$dir/dev"  || mount --rbind /dev "$dir/dev"
    mountpoint -q "$dir/run"  || mount --rbind /run "$dir/run"
    msg "Entrando em chroot $dir (digite 'exit' para sair)…"
    chroot "$dir" /bin/sh || true
    umount -R "$dir/proc" 2>/dev/null || true
    umount -R "$dir/sys"  2>/dev/null || true
    umount -R "$dir/dev"  2>/dev/null || true
    umount -R "$dir/run"  2>/dev/null || true
    success "Chroot finalizado"
}

# -------- usage --------
usage() {
cat <<EOF
Uso: pkg <comando> [opções] [pacotes]

Comandos principais:
  install [--force] <pkg>...   Resolver deps, compilar em fakeroot e instalar no /
  build <pkg>...               Apenas compila (sem instalar)
  remove <pkg>...              Remove pacote instalado
  revdep                       Corrige dependências quebradas e remove órfãos
  depsolve <pkg>               Resolve e instala dependências de um pacote
  sync                         Sincroniza repositório Git (git pull/clone)
  upgrade                      Recompila pacotes instalados com versão maior
  world                        Recompila todo o sistema (ordem por deps)

Utilitários:
  search <termo>               Busca por nome/descrição no repositório
  info <pacote>                Mostra metadados do pacote
  clean [alvo]                 Limpa: sources|build|fakeroot|logs|all (padrão: all)
  check                        Verifica integridade (arquivos ausentes)
  chroot <dir>                 Monta binds e entra em chroot

Exemplos:
  pkg sync
  pkg search zlib
  pkg info autoconf
  pkg install --force autoconf
  pkg clean build
  pkg chroot /mnt/chroot
EOF
}

# -------- dispatcher --------
cmd="${1:-}"; shift || true
case "$cmd" in
  install)
    FORCE=0
    if [ "${1:-}" = "--force" ]; then FORCE=1; shift; fi
    [ "$#" -ge 1 ] || { usage; exit 1; }
    for p in "$@"; do
        msg "Instalando $p (force=$FORCE)"
        pkg_depsolve "$p"
    done
    # fetch em paralelo para todos
    pkg_fetch "$@"
    # prepare/build/install sequencial respeitando deps já resolvidas
    for p in "$@"; do
        pkg_prepare "$p"
        pkg_build "$p"
        pkg_install "$p" "$FORCE"
    done
    ;;
  build)
    [ "$#" -ge 1 ] || { usage; exit 1; }
    pkg_fetch "$@"
    for p in "$@"; do pkg_prepare "$p"; pkg_build "$p"; done
    ;;
  remove)
    [ "$#" -ge 1 ] || { usage; exit 1; }
    for p in "$@"; do msg "Removendo $p"; pkg_remove "$p"; done
    ;;
  revdep)    pkg_revdep ;;
  depsolve)  [ "$#" -eq 1 ] || { usage; exit 1; }; pkg_depsolve "$1" ;;
  sync)      pkg_sync ;;
  upgrade)   pkg_upgrade ;;
  world)     pkg_world ;;
  search)    [ "$#" -eq 1 ] || { usage; exit 1; }; pkg_search "$1" ;;
  info)      [ "$#" -eq 1 ] || { usage; exit 1; }; pkg_info "$1" ;;
  clean)     pkg_clean "${1:-all}" ;;
  check)     pkg_check ;;
  chroot)    [ "$#" -eq 1 ] || { usage; exit 1; }; pkg_chroot "$1" ;;
  ""|-h|--help|help) usage ;;
  *) error "Comando desconhecido: $cmd"; usage; exit 1 ;;
esac
